# @NOTE that chat subscriptions objects function as an index for user's and their
# channels. They are merged into channel objects after the query. The GQL and
# the schema are blind to them.
type Channel {
  createdAt: String!
  updatedAt: String
  id: ID!
  type: ChannelType!
  name: String # null if type === DM
  lastMessage: Message
  messages: [Message!]!
  messageCount: Int
  ownerUserId: String # null if type === DM
  # @NOTE If channel is assistant type then assistant is first element in the
  # array and the userId is second element.
  users: [Profile!]!
}

# A summary of a channel that can be embedded in the Message type or any other object.
type ChannelSummary {
  id: ID!
  type: ChannelType!
  name: String # null if channel type = DM
}

# The different types of channels, dude.
enum ChannelType {
  ASSISTANT
  DM
  GROUP
}

# A chat message or action.
type Message {
  createdAt: String!
  updatedAt: String
  id: ID!
  # ID of the channel it was sent in.
  channelId: ID!
  channel: Channel!
  # ID of the user who sent the message.
  # 'assistant' if the bot is a sender.
  senderId: ID!
  sender: Profile!
  action: String
  metadata: JSON
  text: String
  attachment: MessageAttachment
}

type MessageAttachment {
  type: String!
  url: String
  elements: [MessageAttachmentElement!]
}

type MessageAttachmentElement {
  title: String
  imageKey: String
  subtitle: String
  defaultAction: MessageAttachmentElementDefaultAction
  buttons: [MessageAttachmentElementButton!]
}

type MessageAttachmentElementDefaultAction {
  type: String
  url: String
  text: String
}

type MessageAttachmentElementButton {
  type: String
  url: String
  text: String
  title: String
}

input MessageInput {
  # ID of the channel it was sent in.
  channelId: ID!
  # ID of the user who sent the message.
  # 'assistant' if the bot is a sender.
  senderId: ID!
  action: String
  text: String
  attachment: MessageAttachmentInput
}

input MessageAttachmentInput {
  type: String!
  key: String
  bucket: String
}



# Messages are sent inside a wrapped Input GQL type. We use an Input wrapper
# because the chat UI on the client side may be something other than a textbox,
# something like a button group or a date picker.
input ChatInput {
  # Tells the mutation not to queue a job for this input.
  bypassQueue: Boolean
  # The component which this input came from.
  component: String!
  # An ISO-8601 formatted date
  createdAt: String!
  # ID for this input, generated by the client side..
  id: ID!
  # Channel ID
  channelId: ID!
  # User who sent the input
  userId: ID!
  # An open ended object of values that can be used
  # by the input handlers.
  values: JSON
  # The message to be persisted and/or published to the right channels, depending
  # on whether or not the message contains an action. It's not the client's
  # responsibility to know how a message is persisted or routed. Just send
  # the message and be done.
  message: MessageInput

  # @NOTE: Contexts and events are not sent by the client anymore. Instead,
  # the input handlers are in charge of setting any proper context or event
  # data. Input handlers choose what context or event to send to API.ai
  # by using the input component name.
  # Context to be sent with the API.ai query.
  # @TODO verify the JSON structure before sending.
  # context: JSON
  # Event to be sent with the API.ai query.
  # @TODO verify the JSON structure before sending.
  # An event has a priority over a text query.
  # event: JSON
}

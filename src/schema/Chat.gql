# @NOTE that chat subscriptions objects function as an index for user's and their
# channels. They are merged into channel objects after the query. The GQL and
# the schema are blind to them.
type Channel {
  createdAt: String!
  updatedAt: String
  id: ID!
  type: ChannelType!
  # Name is null if channel type === DM
  name: String
  lastMessage: Message
  messages: [Message!]!
  messageCount: Int
  # ownerId is null if the channel type === DM
  ownerId: String
  # If channel is assistant type then the only element is the user.
  users: [User!]!

  ### SUBSCRIPTION FIELDS ###
  lastRead: String
  unreadCount: Int
  mentionCount: Int
}

# A summary of a channel that can be embedded in the Message type or any other object.
type ChannelSummary {
  id: ID!
  type: ChannelType!
  name: String # null if channel type = DM
}

# The different types of channels, dude.
enum ChannelType {
  ASSISTANT
  DM
  GROUP
}

input UpdateMessageInput {
  # ID of the channel it was sent in.
  channelId: ID!
  timestamp: String!
  # ID of the user who sent the message.
  # 'assistant' if the bot is a sender.
  senderId: ID
  text: String
  attachment: MessageAttachmentInput
}

# A chat message or action.
type Message {
  createdAt: String!
  updatedAt: String
  id: ID!
  timestamp: String!
  # ID of the channel it was sent in.
  channelId: ID!
  # ID of the user who sent the message.
  # 'assistant' if the bot is a sender.
  senderId: ID!
  sender: User!
  # Mainly for real time interactions like typing, read receipts, and
  # disabling inputs.
  action: String
  # Metadata should be moved to the element level.
  metadata: JSON
  # Text and attachment fields are mutually exclusive. If a message needs
  # an attachment and a text then the attachment should include a text element.
  text: String
  attachment: MessageAttachment
}

# An attachment that can give messages superpowers. It outlines a specific
# component that can be displayed in place of a text message. It may be
# a card, image, etc.
interface MessageAttachment {
  # The component to be displayed. Could be generic or could be specific.
  type: String!
  # The action this component should trigger. Possible actions are: redirect,
  # message, postback. A redirect action redirects the client to a specific
  # route. A message postback sends a message for the user. Postback
  # sends a postback mutation and let's a service handle it. If the action
  # is a postback then the postbackId must be set.
  # The action can be overridden by an element. Elements may have different
  # actions - this is handled by the specific components though.
  action: String
  # Postback ID corresponds to some sort of unique action. The chat service
  # is unaware of any logic behind postbacks - it's just the messenger.
  # It's not a required field because an attachment might just be something
  # uninteractive like text.
  postbackId: String
  # Whether or not to disable the input that's displayed at the time the message
  # is received. If we're in the flow of things and don't want the using
  # messing it up we can disable the input. This happens often actually.
  disableInput: Boolean!
  # Fields that are specific to the attachment are defined by types that
  # implement the interface.
}

type StudioSessionInquiryAttachment implements MessageAttachment {
  type: String! # Image
  action: String # redirect, message, postback
  postbackId: String # *
  disableInput: Boolean!
  studio: String!,
  date: String!
  hideButtons: Boolean
}

type ImageAttachment implements MessageAttachment {
  type: String! # Image
  action: String # redirect, message, postback
  postbackId: String # *
  disableInput: Boolean!
  src: String!
}

# Shows a hint-like, centered text.
type EventAttachment implements MessageAttachment {
  type: String! # Image
  action: String # redirect, message, postback
  postbackId: String # *
  disableInput: Boolean!
  text: String!
}

type CardGroupAttachment implements MessageAttachment {
  type: String! # CardGroup
  action: String # redirect, message, postback
  postbackId: String # *
  cards: [CardElement!]!
  disableInput: Boolean!
}

type CardElement {
  title: String!
  subtitle: String
  buttons: [CardElementButton!]
}

type CardElementButton {
  title: String!
  # The unique name for this button.
  name: String!
  # The unique value for this button. The action attachment determines
  # what happens to this value.
  value: String!
  action: String!
}

# Chat postbacks are sent from attachments. It's up to the attachment component
# to sent a postback. Postbacks are then translated to service-specific functions.
input ChatPostbackInput {
  # Knowing what channel this postback came from would be useful.
  channelId: String!
  # What logic needs to be executed.
  id: String!
  # When was the postback initialized.
  # @NOTE we have to use microtime in case a message is returned.
  createdAt: String!
  # Values are optional, but most postbacks should include values to feed
  # to the logic functions.
  values: JSON
}

# Messages are sent inside a wrapped Input GQL type. We use an Input wrapper
# because the chat UI on the client side may be something other than a textbox,
# something like a button group or a date picker.
input ChatInput {
  # Tells the mutation not to queue a job for this input.
  bypassQueue: Boolean
  # The component which this input came from.
  component: String!
  # An ISO-8601 formatted date
  createdAt: String!
  # ID for this input, generated by the client side..
  id: ID!
  # Channel ID
  channelId: ID!
  # An open ended object of values that can be used
  # by the input handlers.
  values: JSON
  # The message to be persisted and/or published to the right channels, depending
  # on whether or not the message contains an action. It's not the client's
  # responsibility to know how a message is persisted or routed. Just send
  # the message and be done.
  message: MessageInput

  # @NOTE: Contexts and events are not sent by the client anymore. Instead,
  # the input handlers are in charge of setting any proper context or event
  # data. Input handlers choose what context or event to send to API.ai
  # by using the input component name.
  # Context to be sent with the API.ai query.
  # @TODO verify the JSON structure before sending.
  # context: JSON
  # Event to be sent with the API.ai query.
  # @TODO verify the JSON structure before sending.
  # An event has a priority over a text query.
  # event: JSON
}

input MessageInput {
  # ID of the channel it was sent in.
  channelId: ID!
  # ID of the user who sent the message.
  # 'assistant' if the bot is a sender.
  senderId: ID!
  action: String
  text: String
  attachment: MessageAttachmentInput
}

input MessageAttachmentInput {
  type: String!
  key: String
  bucket: String
}
